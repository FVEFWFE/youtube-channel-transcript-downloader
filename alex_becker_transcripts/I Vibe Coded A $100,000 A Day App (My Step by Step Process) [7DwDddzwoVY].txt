Title: I Vibe Coded A $100,000 A Day App (My Step by Step Process)
Video ID: 7DwDddzwoVY
URL: https://www.youtube.com/watch?v=7DwDddzwoVY
================================================================================

No, you oversensitive, emotional, silly Sally. Take your Xanax pills. Calm down. The title of this video, not clickbait. I have SAS companies that are generating me well over $100,000 per day. And in this video, I'm going to show you how as a CEO and a non-technical founder, how I vibe code the [&nbsp;__&nbsp;] out of these. And look, I know you as my viewer, you might have been wondering the past 45, 60 days, why have I been making videos? Where have I been? And the God's honest truth is once Opus 4.5 dropped, it unlocked an ability to code and add things to my SAS companies that I never had before. This is equivalent to giving a college kid who's just been getting drunk on beer the last couple years a juice energy drink. If you guys remember those things, it was it was caffeine mixed with excessive amounts of alcohol. You would get [&nbsp;__&nbsp;] wasted off one. It was it was wonderful. And just like discovering Opus 4.5, it was the point where code from LLM has hit the point where as a non-technical person, you can build substantial significant improvements to your SAS company or just vibe code a company from scratch if you know what you're doing. And in this video, I'm going to be breaking down my entire process for doing that at my companies and where we've made huge giant leaps with my companies to achieve this. On top of this, I'm going to be breaking down how you should be doing this if you're a new founder and you actually want to code from scratch and how to work with your developers or if you're a developer how you should be working in your systems right now. And yes, what I'm going to do is is the typical vibe coding CEO is going to be telling you as a person and an engineer how you should be running your code if this video wasn't [&nbsp;__&nbsp;] obnoxious enough. And so that's it. We're going to go through the entire process start to finish. Here it is and everything we're going to go through. Let's begin. So, first off, what is vibe coding and agentic coding? And does it can you actually code? Can you actually do this on production software? Can you actually do this to make money? Not these little stupid shitty apps you see everybody doing, not to organize your email. Can this be done at large scale or to build your first company and start making money through? The answer is yes, with caveats. Right now, what people think vibe coding is is they're either in two camps. One, they either think it's some useless stupid silver spoon preachy developer thing. they won't touch it kind of vibe or your person who's screaming developers are [&nbsp;__&nbsp;] engineers are over, no one needs developers ever again on Twitter. And both of these people are [&nbsp;__&nbsp;] They're both wrong. I'm going explain to you why. See, engineering is is not dead. And developing and needing engineers is definitely not dead either. You're not going to be replacing any engineers anytime soon because developing software still takes engineering, which is knowing how the architecture of the software goes together. I don't care if you have people building your house, which is the AI. You still need to know if you're the architect how everything goes together and fits together. You need to be able to plan. You need to be able to structure ideas. You need to be able to plan how things are going to work and fit together in the system that you're building. So, what does this mean? I don't think vibe coding is capable of building or adding anything to your companies. I don't like the term vibe coding because you really don't know what the [&nbsp;__&nbsp;] you're doing and you're just going off vibes. I do like the term agentic engineering, which is just basically a fancier way to say vibe coding. It makes me feel better about myself. But in truth, what we're doing is we're going to be doing the same engineering that you see done in software, the same processes that come to planning, building, and putting it all together. But we're going to be using agents to code a lot of it and agents to review the code. And you can do massive amounts of improvements to live apps, large apps. And if you understand how to put this together in your softwares and the strategy behind it, you can do it on large production apps. You can use it to start apps from scratch and start billing and running a completely legitimate software company. and you can use it to make massive improvements to how your company works as well. I'm going to be showing you examples of all these right now. So, look, this isn't going to be a how-to to use Claude and Opus and everything that comes with it. I will make one of those if you guys really want. I just feel there are better videos on it on YouTube. And the more important thing to using Opus or any of the LLMs, it doesn't matter which ones you're using, is understanding the process that you go through with the LLMs to plan, structure, and then develop your apps. The the process is what matters. It's the conversation you're having with LMS. It isn't the specific techniques you're using. From my point of view, which is not someone who's doing massive there's the super genius engineers out there, okay? And there's the people that are building all sorts of crazy technical stuff. If you're building some new functional form of technology that's able to send people back in time, please disregard what I'm saying here. But for the most part, if you're trying to get results with vibe coding or what I'm going to refer to as agentic coding to sound scientific and smart for the rest of the video, you don't need to be doing all these technical crazy things. If you're going and browsing around, you're seeing people running eight different windows at once. You're going to see people talk about Ralph loops and you're going to be see talk about their all their agents and their skill setup and their building steps. And the truth is if you just understand how the process works and how context windows work and how overall the thing is going to be thinking and putting things together, you don't need to be doing complicated anything. And in fact, I think the complicated anything make it even worse because as you're building something, it's like if you're building out a house, you need to go one step at a time and you don't need to be doing 5,000 different things all at once. And yes, there's all sorts of automations and clever [&nbsp;__&nbsp;] but you don't need the clever [&nbsp;__&nbsp;] You need to be able to carefully think about what you're doing because when you're building these things, it often doesn't require this thing to sit there for 12 hours in code. You're going to work with it. It's going to do it for 20 minutes and you're going to come back. So, first let's back up to that right there. We don't want to get into the super technicalities of this. I want to show you the overview and the thought process how to use and then you can of course go figure out how to learn how to use clog code or something on your own if you're not using it. I don't I if you're a founder right now and you're not ability you don't have the ability to use cloud coder or opus or anything like that, you really are just behind. So you should get your [&nbsp;__&nbsp;] together. But that being said, you need to understand as we get into this how you're going to be applying this. You're not going to be cracking open your large production software. I'm not going to be cracking open just booting up, throwing it in in VS Code and Cloud and just going to town on the thing. Okay? That's not how I want to do it. And I also don't want to go to certain parts of the software and start coding on it. I also don't want to be messing with the general software overall because what you're going to see when you're working with really large apps is the problem with really large apps isn't the fact that you can't write code [&nbsp;__&nbsp;] fast enough. It's the fact that the code needs to be reviewed and every code affects every other part of the code of the app and it has to be understood how it goes in there. And even if the code you pass doesn't have bugs in it, say you don't pass bugs for two, three months, the problem is slowly people stop understanding the code and they slowly start stop understanding how everything fits together. So again, even if you're coding with LMS or you're coding uh by hand, the main issue you're going to run into with large apps, it doesn't matter whether which route you're taking is making sure that the architecture and everything you're building fits on top of each other. And you're going to run into the same issue with LMS if you're using it to write code because it's like you're trying to build a Lego castle and you're not thinking about what's going on this part of the Lego castle or maybe someone's building in the Lego castle over here and they're not considering what's happening over here. And if you have two people building, even if they're working with the best AIS on earth, if they interject with it, they're not going to fit together. And you do have a giant big old problem just like in normal code. So again, you're still going to run into a lot of the large problems that you have at scale when it comes to coding by hand. And you really don't save that much time coding with AI unless you understand how to use it to give like huge massive impact very quickly and segregate what you're doing from the rest of your product. So, I need you to understand that rough little analysis I just gave you before you actually start talking about how we're going to be coding our apps. So, in this example, I'm going to use one of my companies, Hyros, and we're doing about $40 million a year right there, cruising past that. We're growing about 30 40% a year right now. So, it's going well. Companies, it's it's it's a serious company. We're not we're not selling ice cubes in the side of the road. And at Hyros, it's gotten to the point where I'm spending about half my day developing and engineering solutions for the product. It's actually just crazy. So that's one of the reasons I've been making videos because we're getting so much [&nbsp;__&nbsp;] done because of the huge breakthroughs in in LLM and AI coding that just way more profitable and better for my time just be doing this all day. So I want to show you how I think about this at the company and how it's being used on a live giant working service. You can take any of these and apply them to your existing businesses. You can also use them to start another business from scratch. There have been things I have coded up or aically coded. I'm just going to use the word coded in parentheses because I don't think I'm here writing JavaScript and and building out my apps. I think I'm vibe coding, but we're just going to say coding. Okay, I'm not going to say it anymore or explain the difference between them. But I've coded up things at Hyru that could be their own softwares by themselves and I could easily start selling. My goal is to build a company that's making $100 million per year. So, I'm not going to do that right now, but feel free to take these all away. So, as we look at this right here, I want to talk about the three types of apps you can build. So the first thing you need to understand that vibe coding gives you the ability to do at your companies is MVP things very fast and find the technical solutions that can be implemented in your software very fast. So for example if you're a product person which I am my main job at Hyros is to think of the product the designs and everything that's going to go there. You can think of a lot of things and how you want your product to work but technically the things you think up you're not always going to to know exactly if that's the way they're going to be put together and work. So, for example, when you're building an AI agent bot or something that sends emails or manages some part of the company or uh captures code in some certain way, the code and how everything puts together, your team's going to have to figure it out and encode it into your solution. And that can just take a lot of time just for them to research and figure out, much less find the best way to actually optimize it. So, for example, one of the things you can do is build parts of your app that you want to have, build the features out and find the optimal ways for them. So, for example, at our software, Hyros Air, we're able to pinpoint people coming to websites and recognize them uh regardless of whether they enter anything on the the website and follow up with them via e-commerce emails and reps and all sorts of cool stuff. But one of our bigger problems was we had a really hard time making good-looking emails. And so, I had to go and figure out like how can we make these emails look really good when they're generated by AI. And it takes a lot of combinations and you have to know exactly what things are going together and how all the system prompts and user prompts are all put together. And I didn't want my team spending all their time that they would be spending developing features actually figuring this out. So I was able to work with Claude and actually come and develop an app that allows me to test basically any type of generation method with AI the second comes out and I'm able to vibe code and it allows me to then make really beautiful emails and then find the cost and make things optimal for the software and then pass the optimal code to my team. And so I'm able to go and test all sorts of different product features and strategies for the product very very quickly and then find the best version of it and then take the code from that. Have Claude go generate the code that would be optimal based on the high-risisk code and then give that to the team and say hey put this into the product and find a way to put it in there. And so then the engineers time is only spent doing things that are making money and making the features better. This is one of the best ways that I found at first to use it. Now the next thing you can do is also code up things that allow your team to work faster. So for example, one of the most difficult things at Hyris is we have a lot of complex setups that our customers have to use to install the app. Once they do it, their ads absolutely [&nbsp;__&nbsp;] money. By the way, if you're watching this, you have a SAS company. I think you should be using Hyris. There's a reason why everybody uses it because you plug in your ads, you're going to make 10 to 15% 20% sometimes more from your ads. Particularly SAS and B2B ads. This is why every big brand in the world uses it. You can come check it out right now. You can use it. It has a 90-day refund guarantee. If you don't see results from it, you don't see the results I just talked about, you don't pay for it. But we've been around for a very long time at this point. We have thousands and thousands of customers. It's a pretty big company. So, if it didn't work consistently, we wouldn't be there. You should come use it if you're watching this video and you want to make more money from your ads, particularly if you're a SAS business. Anyways, at our SAS company, one of the hardest things is managing people's installs and then keeping all the install documentation up to site up to date on our sites. And so, one of the things you can do, and I'm going to show you the really cool apps here in a second, but I I you some people might roll their eyes because the sexiest thing you build is is infrastructure apps for your business, but this is one of the best applications for it. So you can see with this app right here, what it does is it allows my team to go and manage all the documentation for the business. And you can see if we scroll this over right here, it has when the documentation is uploaded, when it's marked good, it has the person's signed name next to it. And what happens when people are using this with one of our install apps, when the installs go wrong, the customer reports bad, the status turns to bad, it alerts the team, and then they go and check what happened with the bad status and then update doc. And so what this allows us to do is simultaneously manage hundreds of docs that talk about the installs and keep them up to date with what's going on with the companies. And so you can see we used to have a really ugly um documentation website, but I went in and made an entirely new documentation website that manages all this and it plugs into these txt files which then also can then be plugged into Claude. So Claude can set up our our app for our customers as well. But regardless, I was able to go and get all these txt files and it updates these. Cloud's going to look at the TXT files and then rewrite our documentation based on the txt files. So, it's sim it literally allows us to do one of the biggest challenges that we had at our company effortlessly and stay on top of it without our our customer support team having to manage and write hundreds of docs and stay on top of it manually. It's all done for us directly from this system. So, the next thing you can use this for at your companies is infrastructure in your companies. All right, so we have all sorts of new apps and all things to make our teams lives easier. Massive, massive, massive unlock. Just these two right here allow us to get so much more done at Hyros that is focused around getting results for the customer and the product itself. So the two thing I want you to notice right here is we found a lot of ways to segregate what we're building from the actual software itself. This is important because you need to realize when you go in and mess with actual software, the deep internal guts of the software, you're not going to blow everything up. You can 100% use agentic coding inside your software using the steps I'm going to show you in this process. You want your engineers knowing this stuff. You want your engineers working like this. You want your engineers using LOMs a lot when they're coding. There's ways to use it in a controlled format that definitely work. What I'm saying right here is especially if you're a non-technical founder and you're looking to get not be engineering your main software kind of like I do or working with the teams and and the things they're doing, you need to be understanding that one of the best ways to use agentic coding is when it's segregated from your software because then you can make little mini apps to get massive massive progress for your company done that are completely risk-f free to build. And if if you understand the basics what I'm going to show you in this video, maintaining these and keeping these going is effortless. Okay. So, the final thing I'm actually going to show you is actually userused applications. All right. So, I'm going to show you one thing that we've created right here. All right. So, this is actually a setup extension and I built and what it does is, well, I'll just show you what it does. I can type in WordPress right here. And what we had the biggest problem with at Hyros was people getting set up and installing Hyros. So, what I did is we created that that TXT system I showed you. And then I created an app that is going to allow LLM to essentially watch your screen while you're doing setup. And then it walks you through step by step how to do the entire setup. So if I use this app right now, it will walk me through screen by screen, tell me exactly what to do to set up Hyros for WordPress or whatever I type in. It will go scrape my site, look at my stack, and it will go and then tell me what to do. It's basically like having a customer support agent that will sit by with our customers and help them install Hyros, which was our single biggest blocker. Like that's the big problem at Hyros. It's not that it doesn't get results or works. Every time when people come in and set this up, they see huge results in their ads. It basically prints money for people when they come in. It's getting them to take the effort to sit down and actually install it, which in the in the past required people to have to sit down, go through our documentation, figure out their stack, set up, work with our customer support people, get on customer support calls. And as good as our customer support is, people don't like dealing with customers. So that was one of our biggest reasons for turn is because it takes a little bit of time to set up Pyros. Not anymore. And so we're able to use vibe coding to go and solve massive huge chunks of our business. Now with vibe coding as well, we've made I've been working [snorts] on huge leaps at Hyros that allow us to get the raw data, use the APIs to build stuff. There's just nutty [&nbsp;__&nbsp;] we can put into the software. And if you're thinking about when you're building these type of of mini apps inside of your business, if you think when you're using it for your users or you're giving it to your users, how you can either build stuff that sits outside the software, okay, kind of like this Chrome extension right right here. All right, sits outside of software. I can work on this all day without really risking the app and I can create extra systems that there that uh benefit the customer without really risking the app. Next, you can actually create apps that sit outside the software that can be API called. So for example, I've made a scraping software that our system when people are going through onboarding can use to figure out what sites they need, what their setup process is going to look like. And then Hyru will ping that API so it sits outside the software. Again, I we can work on this, do all sorts of stuff on this all day, lowrisk. And then finally, when you're actually building inside your software, finding ways to structure your architecture so that vibe code specific areas like your front end or your onboarding areas or places that don't really need access to your complicated back end of the software, usually the user interface where your team can lose so muching time coding it. for example, going and changing the UI or changing uh the setup area inside the software, the menu areas or the onboarding systems. Those used to take teams very long amounts of time to do. And so they were working on these instead of building the features that get people to buy your software. These are the most important parts of your software though. Onboarding is the most important part. If you see me talk about on the channel all the time, if you can find ways to segregate the code so you can work on those parts of the app risk-free, then holy moly, you're you can you can you can just cut literally half the development time off your software and put your teams purely on money-making development. These three uh views altogether just [&nbsp;__&nbsp;] money and make and make if you're a non-technical founder or product person, you can just get so much done. It's ridiculous. Uh, I for the past 60 days, I've just been coding and making apps and coding and making apps and coding and making apps that have just removed so much like freaking red tape at high-risisk. It's insane. Now, using the process I'm going to give you for these, you can even start developing inside your app. You just have to move a little bit slower and be a little bit more careful, especially because you're working with lots of other developers. It's not something I I suggest you doing. I really suggest you giving these smart processes I'm talking about to your developers and having them use it because at the end of the day what doing highlevel development is is it's not writing code. A lot of people can write code. It's understanding how all the code fits together which the AI can do but it's understanding how to make the AI understand what it's looking at and giving the AI enough context and when the AI is working on understanding what the AI is doing to the code which can be done even if you cannot write code. You can still look at what the AI is doing and look at the work it's done and figure out what it's doing. You can even ask it what it's doing. You can ask explain what it just did. And you can if you understand how your app works as a whole, then you understand what it just did to the rest of the app. And so even when you cannot code, you should be able toing read some base code. If if you work in SAS and you're if you can't reading code, like you should understand the gist of where all the files are. You should be able to look at VS Code in your app and like know where the things are. But if you're not even a top level engineer, most of the work is actually still keeping in track of where everything in your software is. So when Cloud does something, it tells you what it does and you know exactly what it did to the rest of the software regardless if you can understand the Python or the JavaScript or Nex.js or whatever the [&nbsp;__&nbsp;] it's written in. Okay, so this being said, let's talk about how we would go and actually do this entire process. I want you to think first though, like I just said, how you're going to be using this. Okay, it's not just rip open your software and start coding on it. Okay, so I'm going to show you my entire process from start to finish. Now look, do I think this is the most technically super duper impressive way to be using CL? Yes, baby. Actually, I'm a [&nbsp;__&nbsp;] genius. This stuff is this stuff is awesome. I think I'm pretty damn efficient at this. That being said, you're going to see all sorts of setup strategies and loops and technical things and ways to manage the context window that I think if you're trying to get stuff done, I don't think are needed. I think it's much more important you understand how cloud works. Even if your developers are working on your large software, you don't get the results from more complication. You understand that you get the results by understanding how cloud works and making sure claude always has context of what it's doing and full awareness of what it's doing. You're watching what it's doing and you understand what it's doing to your software, which doesn't take a complicated setup. It takes understanding the process and the train and the assembly line of what you're building. Okay? everything else, all the the loops, the agents and and stuff like that that people create. Oh, I got six agents doing six different things at a time. I don't understand the purpose of that because it's just excessive stuff and that's not how you want to build something. It's like if you're writing a novel, you don't want to have something go and you have eight different uh writers all writing your novel at once. You want to write chapter one. You want to review chapter one. You want to carefully go through each part of chapter 1 and make sure it's aligned correctly before going to chapter two. Okay? And as you start making the book, there's going to be things you discover as you're building. Okay? You're going to maybe get to chapter two and say, "Oh, okay. The character should work this way." If you have all these eight different things and everything, you're not carefully crafting what you're doing. And frankly, you don't need to write that much [&nbsp;__&nbsp;] code to make an app. Okay? Look, I know there's if you're making your own internet browser, your own coding language, something. Yeah, maybe you do. But if you're adding a feature to your app, if you're adding a tool for your users, Claude is probably going to need to only swing at it for about an hour. And the most important thing is you're thinking about your users and the process and what you're building and how Claude understands it while it's doing it. So when you give it a command, it understand how it fits into the process. And this is where this process starts at. Okay. So while this not might not be the most technical, you can get really good [&nbsp;__&nbsp;] results with this. Okay. So I'm going to walk you through the planning process all the way to the actual vibe coding process itself. So the first thing you want to do is I I I I use clawed code exclusively. And if we pop open, I'm just going to show you my setup. And I usually have three terminals going the same time. I just kind of crush these all together. Usually I'm just looking at one terminal and I'm moving from one at a time. I don't have them all three open at the same time. That's ridiculous. I know you see people screenshotting that on X. That'sing stupid. You don't need this much text all at once. What I'm usually doing is throughout the day when I'm in like coding mode, I'm just going to have three going at once, which sounds impressive, but it's not because all it does is it goes and works for 5 10 minutes. And then at 5 to 10 minutes, you talk to this one. And in that 5 to 10 minutes, you talk to this one. It's that damn simple. Okay. But what my setup is going to be is I'm just going to use free VS Code. Open the terminal. I'm going to have the eye over here. All right. I'm going to have all my files and everything over here um that I'm going to be looking at. If I need to look at them, you don't really need to be looking at the code. You can look at the code if you want. Especially these smaller apps. There's no point. You don't need to be looking at the code. Like there's no point. If you're doing it with your main software base, yes, you need to be able to read the code. With these smaller apps and everything building, no, you don't need to do the code reviews and if you have enough context and you build it's right with Claude and you understand how to give it context. You don't need to look at the code. I'm sorry you don't I have had no issue for 60 days straight and I've built a lot of [&nbsp;__&nbsp;] and I've built [&nbsp;__&nbsp;] that actually does important stuff in our business and there's no problems. Okay, so it's it's more about how you understand how it fits together and the reason why there's no problems because I understand how it fits together which I'm going to communicate to you right now. So you're going to see people using cursor and all sorts of crazy stuff. I love cursor as a company. I think it's cool. I don't understand the point of it. All right, I don't. You really just need a [&nbsp;__&nbsp;] terminal or you need a chat box and you can just get all the stuff done. You see all the complicated steps, but that's it. So, what I'm going to be doing and I'm just going to work over and make this the main thing we're going to be working on because this is what we're building and I'm going to be talking about how I built this today literally. Um, so what I'm going to have most of the time going is I'm just going to have my setup like this and I'm going to work directly like this most of the time. If I need to read files or look at specific things, this is what I'm going to be looking at. This is where I'm going to be working at most of the time. And I'm just going to be just chatting this little box right here. Now, before we come over here, what a lot of people try to do is they plan inside the terminal, which is fine. I I think that that's great. You can just come over here, plus shift tab, shift to plan mode, and u you know, talk to claw and say, "Okay, I want to add a new browse feature. Let's discuss. give me a list of feature ideas that we could add in list format. Okay. And so what it's going to do is it's going to go in and help me plan and start working through the software. This is a great way to plan out your software. This isn't how I like to do it though. And I think my method is a little bit better for stupid people like me, which I assume you are. Okay. I don't like doing plan mode in this because you're going to spend a lot of context doing this and you're going to add and to test things and to build things out. you're going to have to create a lot of test code. And I like to make test code before I go and actually start developing the right product. And I don't like to make my MD files and everything inside of this. Okay. So, you can see it's actually giving me a bunch of ideas and things I can work with and I'm and planning stuff. I don't want this in here. So, I'm going to hit escape escape and go back and revert. All right. So, that that's the setup that I have right here. So, what I want to do is explain why I start off inside of Claude. All right. And so one of the reasons I also want to break down why I'm doing this is I see a lot of videos on YouTube and X then they're made by developers for developers and I don't really see a lot of product people making coding or agentic coding instructions and here's why I think this is really really important. If you look at at softwares developers and engineers are very very important but what they're usually not doing is doing the proc designs and the design process how the feature is going to look and feel and do and that's the most important thing. Look, I'm not in this video putting and saying developers or engineers are not needed. They are super duper and critically important. If you can do what I'm doing right here as an engineer, you're like [&nbsp;__&nbsp;] Moses right now partying the Red Sea. Like you are just the most valuable person on planet Earth. The reason why I think what I'm talking about right here is very important is because I'm coming at this from a product and a product designer angle. And in order to think out your product and how to get it right, you got to do a lot of testing and then you got to understand how to develop it with Claude. And if you're doing it inside the terminal and you start in the terminal right away, you're going to make lots of dumpable code and it's just going to be a big old mess and it's just easier to do everything inside of Claude and brainstorm with Claude uh from the actual just the basic simple system right here. And I think look, you are going to be using this as not probably the senior engineer of your company. And so you want to do things and keep them in simple formats. And so what I'm going to show you in this video is kind of dur simple. All right? And a lot of people aren't going to be starting to like he he doesn't work in the terminal. He's not using 16 alphabetical agent skill systems. No, this works and it's easy for everyone to grasp and it's easy for me to grasp. So, let's talk about this. What we want to do before we even think about coding or starting anything is we want to think about starting a conversation with Claude about what we want to build. Okay? And so, what you're going to want to do first off is you want to describe to Claude what you're looking to build. And you want to describe the intent of what you want to build and where it's going to fit into your company and what your company's trying to do with it. You want to explain the problem to Claude. You want to explain the problem that users have. You want to give a rough breakdown of how you think it would look. And you want to not tell Claude, "Okay, just build this." You want to say, "How would this work? What would be the best systems to do this with? What would be the best structure? Assume that I'm a non-technical founder and you need to explain this to me and don't tell me what I want to hear. push back on my ideas. And so what you're going to see is me discussing with Claude in this this instance that we did. I just made a scanning app today that scans our customer sites and then sets up um all the websites that they have in their tech stack. Okay. And then what it does is it passes this tech stock to the extension. So the extension knows the tech stack to go through. Okay. So I pointed out and explain this all to cloud in this and I say all right we this is what we need to do this. So how could we go and set this up? And so what it does is goes and gives a bunch of ideas on how this is going to work and it describes the MVP to me and I go back and forth with it like here's what we need to do and then one of the most important things you can do when you're planning with claude is at tell it to constantly ask you clarifying questions on your idea. So you can see right here um want me to start building this or the working prototype I can create a sign blah blah blah but I say yes but we need to make these adjustments right here. All right. All right. So what you can see me doing right here is going back and planning with it. And this is a very important example right here because you're going to see I was not specific enough with what I was telling Claude to do. And so this was kind of a a throwaway app. This isn't someone that I was thinking super duper deeply about. I was building this while like doing eight different other things. Okay. So you can see how easy this process is once you get it going. And so what I forgot to tell it is make it an artifact. And the reason why I'm doing all this in the in the actual claude uh just in the browser like a like a normal civilian normie is because of one thing. It has this artifact feature right here which allows me to then go and build the feature out and test it inside of Claude because I don't want to put this on my computer. I don't want to run this locally. I don't want to deal with the architecture of of it yet. I don't want to build a plan how it's going to be on Versal or how I'm going to get it on manage GitHub and all that. I just don't want to do any of that right now or manage the superbase store. I don't want to do any of that. All right. I just want to plan out how the thing is going to work and how um the system will work overall because Claude sometimes doesn't know how the system's going to work either. A lot of the ways that we're building things, you don't really know how the final architecture is going to work and you say, "Oh, maybe we want to use this different uh agent right here. Maybe for this response we want to use Grock. Maybe for this response we want to use Opus. And maybe the way we fetch the HTML, it's too expensive. We use uh Opus to do it. Let's instead use this smart fetch feature." And let's see how that works. Oh, this HTML feature doesn't work. let's let's fetch it like this instead. And so you're going to go back and forth with it in the planning phase and figure out how the tech is actually going to work. Uh and and unless you're freaking raptor Jesus developer, you're not going to sit down and know the perfect architecture for every single app right away. And what you're doing as an engineer, an agentic engineer, um, which I've I've signed myself the certification of is you're you're going to go and [&nbsp;__&nbsp;] think of how the damn thing works and how it's going to come together and find the optimal way for it to put together. If I tell Claude, "Make me a tool that scrapes people's websites and tells me their tech stack," it will just make it, but it will miss so much and it won't consider if it's going to work for Hyros or how it's going to work or any of the specifics. and it will make nonoptimal solutions. It could cost tons of credits or tokens or they could just noting work at all and it will just give me the app and I'll put it in cloud code and it won't work and then I've upload this thing to GitHub. It's just a mess. So this artifact step right here when you're planning allows you to go and say all right this is how it's going to work. This is how the rough UI is going to work for this and then you work out all the kinks with it and you just go back and forth with Claude explaining what it's getting wrong or what's not working and you just work on it for a little bit in here until you get the final version of it. Okay. Then when you have the final version of it, what I'm going to do is once you have a final version for it, you go, "Perfect. This is what we're trying to build." So Claude, what I want you to do is I want you to create a PRD or an explanation of what this product is. And you I want you to focus on why we're making the product and the intent and the context of this this thing we're building. We're not just going to go in the claw and say, "Hey, make a scanner app now. We know how it looks. Great. Give me the technical readout. Let's go." We want to make a PRD that explains everything we're doing on this product and everything about the product and how it's going to work and how the features are going to fit together and everything. Okay, this is incredibly important. Not just having a description of the product, but why the product is doing something. So when Claude starts coding later on or wherever make changes, it knows why and what its goal is and what the [&nbsp;__&nbsp;] it's trying to do. Every single time Claude boots up, it forgets everything. So if you show it an app and the app is like scanning stuff, it doesn't know why it's scanning stuff or what the point it is or why it's trying to scan things and so it's going to forget things that you were working on before. Okay, this is called the context window. If you're new to this on context windows, very quickly, if you're looking at this, Claude, for right now, if you're working in cloud code has 150,000ish context units. What this means is that Claude's going to compact the conversation and you just look at it. Think of it like this. Okay? You have a book. All right? And let's say after 30 pages, it's able to do is it's only able to keep so many pages at time. So if you start on page number one and you get to page 30 and you go past that, what happens is it starts forgetting everything that's on page one and knows everything all the way to page five. And so it's a window. It's like a it's like a view. And so if you if you have a bunch of information that's on page one, but the context window is on page five or here, and you tell it to do something, it requires the page one information, it's not going to do it well because it doesn't know that's there anymore. Okay? So it's it doesn't it doesn't think it doesn't remember things. It's just a [&nbsp;__&nbsp;] screenshot of where it is in the book. Okay? And so what's going to happen in cloud code is when it gets to that point, it compacts itself and summarizes everything and shrinks it down. Now, in the past, this used to be extremely critical. This was like the core thing when you were coding with clawed code. You had to worry about it a lot because it got really [&nbsp;__&nbsp;] stupid the deeper it got into the book. And so just be forgetting literally everything all the time. So you try to actually do things in about 150,000 chunk windows. And so you'd work on one feature, you describe everything it needs to know at the start, you'd open the session, get everything done in that window, then document everything, reset the loop, give it everything you just did, reset it over again. I don't do this so much anymore. It is important if you're building like some major feature on your software and you need claude be precise laser. Yes, you you need to maybe be worrying about this right now. If you're doing a Ralph loop, which maybe some of you psychopaths [&nbsp;__&nbsp;] are. That's essentially why the Ralph loop exists. That said, the compacting and claude is so good now that I haven't really had to deal with this. And if you're using codeex, for example, I don't see people having to deal with this either over there. So, I don't worry about this too much. You just need to be aware that that's how it what looks that's how the thing is thinking. So you want to make sure in that context window it knows what it's doing and why the [&nbsp;__&nbsp;] it's doing it. So the reason why we're building all these documents is so when Claude is coding or getting to work, it knows why it's doing the damn thing. We don't just boot it up, give it the code for the scanning app, say, "All right, we're going to need to add a feature right here that helps the the customer know whether their payment processor is is connected or not." Cloud won't know that it's supposed to be related to the ad account feature because it doesn't [&nbsp;__&nbsp;] know what the app is. This is why we give it this right here and this full breakdown of why we're doing it, how the product works and all the features work together. Then what we're going to have it build is an architecture layout so that whenever Claude knows when it's building, it knows exactly how the app all fits together and where everything is and where it's all located at. This is the same exact reason we're doing the PRD. And then we're going to have it create a build plan. It's going to step by step systematically go and tell it everything that needs to be done to build this app out. This is when we're going to start coding. So then we're going to take this on over to Claude Code and I want to show you how we built this. This is a more simpler app. I've had ones where massive big old file base is working with, but I just want to show you the basics right here. We're going to take this over in the cloud code. And this is when we're going to get to work. And there's processes we want to do before that. Okay. So I don't think I'm going to be able to access my conversation history right here, which is going to be okay. That's fine. I'm just going to go through the process. I'd be doing it from the start. All right. So the first thing I'm going to do right here is you can see I have all these files right here. Okay, we have everything and how it's going to be built out. We also have a cloud MD file. All right, so here's the process we're going to be using. The first thing we're going to do is we're going to boot up cloud code. And I'm not going to do it because I want this session right here. You can always just resume the conversation later on. That's a lot what I do. So the first thing you're going to do is you're actually going to go and I'm going to paste in this claw MD file right here that gives it our working relationship rules and everything it should know about the software that we're building right here. Okay. And the most important thing you have in here is these rules that I have first. And so what these rules basically do is give it very good guard rails of what how to behave when looking at code and interacting. This is actually copied from another YouTuber who I'm going to link below. Um, I forgot his name because there's so many making clog code. Uh, but it will be a link below. So, you get the credit, whoever you are. [laughter] I'm just gonna steal everything you said in your video. Okay. All right. So, look, um, what's going on is I have my core rules right here. Understand before acting. So, like if you see code and you're about to work on something, read the code base and relevant files related to it. Don't just work on it. Check in before you go and do something huge to the software. Before major change, check with me. Communicate clearly. All right. every step of the way provide a high level explanation of what you're doing. So when it's coding out stuff, it's telling me what it's doing. I'm like, "Okay, that's what you're up to, little fucker." And if I see it doing stuff that doesn't make any sense, what shouldn't be happening because I I get the plan from Claude before it codes. If I see it doing something or it clearly misunderstood something, for example, we want a TXT readout and it says starting to make the PDF readout. I'm whoa, whoa, whoa. We want to do txt exports, not PDFs. You stop it, it continues again. All right. Simplicity. We want to have it make simple solutions that don't change large parts of the code. Cloud will make some very creative [&nbsp;__&nbsp;] We don't want creative [&nbsp;__&nbsp;] All right. We don't want like endless ways to backdrop other code. We want stone caveman code that is simple. All right. And then we want it to always maintain the documentation of the work it's doing. So you can see these these files right here are going to constantly updated. So when I boot up a new version of claude or cloud is way outside of its context window of where it is, it's going to look at these files and it's going to know exactly what the last claw did and what's going on. So all these things that it's doing are constantly updated on top of the memory that's compacting over here from claude which is still actually very functional and good. The one I have right here is I say you are the CTO. You're also responsible for the entire product. I copied this from a guy on Lenny's podcast. Very good [&nbsp;__&nbsp;] podcast if you're building stuff or doing stuff for SAS companies or for your SAS company. And what I have it basically say here is I'm a [&nbsp;__&nbsp;] idiot. You're a CTO. I'm going to give you lots of ideas but assume I don't know [&nbsp;__&nbsp;] and don't just agree with me. push back on my ideas and find the most optimal code solution. If you don't do this, you're going to give Claude a terrible idea and it's going to be like, "Seems like a good idea, Alex. I guess I'll get to work." And then it codes a back door to Pornhub in the back of your [&nbsp;__&nbsp;] software because you were an idiot and describe and misype something in. I don't I don't [&nbsp;__&nbsp;] know. Okay, it's going to it's not going to do that. But you can come up with really stupid ideas and it'll be like it should be like, "Hey, that's a stupid idea. We should go about it this way." And you're like, "Yeah, okay. Maybe we do that and it will explain to you why it's a stupid idea so you learn. So we put this claude MD file in first. Then we say it will it will look at the cloud MD file by default. The cloud MD file it's going to look at it before it starts doing everything every single time. You say look look at all these files that I just gave you. Study them to the level that you're able to deeply discuss them. Don't just look at them. Don't just tell it well then go skim it. Look at them to the point you deeply understand them and are able to discuss. notify me when you've done this. It's going to spend a lot of tokens. We have a little token scanner down here. It tells us the context window. You can see right here we're at 126,000 tokens. At 150, it's going to reset. And I'm going to know that, hey, some of the things we talked about are going to be forgotten. I don't pay attention to this that much anymore cuz it's it's context window and and compacting works great. And I assume here in a few months when this upgrades again, I don't think context windows are even going to be much of an issue here in the future. So, this is kind of an ancient skill set even now. It's still relevant, but just vibe with me on that. All right. So, look, I'm gonna say read these all to the point of deeply understanding, then tag me. It's going to tag me and say, "Hey, now I understand this." I say, "Okay, we're going to build this from scratch, but ask me any clarifying questions before you get going." Now, if you're new to this, what I really suggest doing is sitting down and going with it phase by phase and having it build something out one phase at a time. Because depending on the complication and how complicated what you're building is, you don't want it to go and build everything all at once. this app right here. I'm like, "Look, just go build the entire [&nbsp;__&nbsp;] thing and I'm gonna go get I'm gonna go make some noodles or something." All right. And so it just goes through this entire checklist that we built for it and builds the entire thing. I come back 30 minutes later and I have the working app. Cool. You don't want to do that for everything. There are some things where you actually want to sit with it phase by phase and really pay attention to the parts that matter. All right. Um, [clears throat] so anyways, what we're gonna then do is I'm gonna say ask me any clarified questions for this because sometimes the things that work over in Claude on the AI chat are not going to be the same over here. And it's it's going to need some questions and answers and it's going to think about some things before it develops it. So you tell it to ask me clarifying questions. It's going to ask you questions in a list right here and then you just answer the questions and say, "Okay, but should this feature be here or should it be here? Should this um should the way it exports files, should it be saved like this or saved like this? This feature makes no sense. Can you clarify how this works? It's going to ask you those things. You clarified it. It's going to get to work. Now, one little tip I'm going to give you before you get started with this is when you're working with it, and this is something I always forgot to do is when you have Claude building out these things, be very specific about where you're going to store it at or where you're going to upload it to. If you're new to this, you're not going to [&nbsp;__&nbsp;] understand that. So, you need to ask it what's the you need to tell it how you want it to be used. So, if you're putting an app online that everybody's going to use or your your team is going to be using it, you're going to be putting in different places. I really like just putting things on Versal and I like storing things on Superbase, but you need to ask it beforehand. All right, let's imagine I'm going to be storing this on the internet in this way. This is exactly how my team's going to be accessing it. What's the best infrastructure for this so that it's simple and works in this way and is easy to maintain? And so it's going to think most of the time, oh okay, um, so this guy is not going to be running it locally on his computer. He's not going to be running it off of Python on the website somewhere or some weird thing. It's not going to be running in this weird winging thing because what it will do when it's building things out is it will just think about the most optimal way to build it. If you don't give it context of where you're going to deploy it at and what it's going to be used for, it's not going to consider that. Okay? So you might get it right, you might not. This is the stuff you have to think about when you're coding with this. And this is how you have to engineer. You have to think about or know this is the most important part. Know what to ask Claude beforehand to bring the right engineering structure and information out of Claude to tell you. You have to be aware of what you don't know. So telling and giving Claude context and then asking it to ask you questions about that context is the best way to find out. For example, if you're starting off, you don't know the best the best uh stack to build this on. You need to say this is how I intend to use this cloud. This is the context for this. What's the best stack? This is this. Okay. When you build the system that we're building right here, the technical buildouts, what you need to do is build it around that stack. Now, there you go. A lot of people don't do that step and so they end up with all these weird ass stacks like Claude gave me an output in Python. I'm not going to be running this locally. What a [&nbsp;__&nbsp;] idiot. You're the [&nbsp;__&nbsp;] idiot. Not not the LLM. All right. So, that said, what you're going to do is I'm this is the overall process to get something built. Okay? This this right here in this understanding I just gave you is like 9/10en of the law. If you understand this, you can kind of move on to anything else, but I'm going to give you the next steps after this anyways cuz why not? So what's going to happen is you're going to have this built out and then you're going to in my opinion what what you want to structure it as is say look we're going to run this locally first but then we're going to upload it to GitHub and then we're going to load it up somewhere. So consider it working locally and on the internet okay on a on a different website Versal whatever you guys want to call putting online. And so that's going to make sure that when it goes and builds these things out, it's going to build your environment, your folder where basically all your API keys and everything is set correctly and it's going to make it so that it works locally on your computer, but when you upload it, it's going to work there, too, cuz using things that work on your computer are not going to work the same way they work on the internet. Okay? So anyways, it's going to go and then launch it locally and then you're going to do all your testing there. Okay? And so pow, I chuck something in. Boom. I got a full high report on everything we're getting in there. So now we got the integration checklist and I can build all sorts of features and an API call into this and all sorts of neat gizmos and stuff like that. So now what I want to do is give you some some basic rules of thumb when you're building stuff because you're just going to kind of get the gist of this and if you're if you need any more steps after this, you're just being a big [&nbsp;__&nbsp;] baby. All right, you got enough you got enough information. Go get in the water. Go figure it out. All right, you're going to flap around. You're make some mistakes. It's fine. All right, you're going to go build some apps wrong. You're going to do some things. You're not going to learn and get it right the first time. That's fine. All right, it's fine. So, I'm going to give you some basic things right now that you need to be thinking about though when when you're building these apps. So, you're going to run into bugs and Claude's going to build things wrong and it's going to build things wronger and wronger based on how badly you are at figuring out what's wrong with Claude. If you're able to set Claude up to win, it's going to figure out what's wrong with things very quickly. If you don't set it up to win, it's going to make all sorts of weird things for this. So, what you're going to do when you test an app, let's say I go and put this up and it gives me a bunch of weird stuff right here. What I want to do with Claude, if it's an obvious bug, like something just missing, I'm just going to say this is missing. Fix it, please. But if it's more of a a intangible bug, like the the the information is coming back wrong or things are displaying wrong, you need to not just tell it to fix something. You need to think about how it affects other parts of the software. Okay? So, you need to say, call it, all right, this is happening right here. And if it's something that consistently keeps happening, you say, "All right, let's think deeply about why this is happening." Find out why it's happening and then give me multiple fixes and while thinking about other problems that can occur after this fix. Okay? And then what you need to do is when it gives the fixes that are listing out, you need to be thinking about and looking at the app and how it's coming back. So, for example, with that with that integration app I showed you where the the assistant was working, what kept happening is Claude got out of sync with the rule system. So how the how it reads the TXT documents, how it um how the TXT documents are written. So it has a rewriting guide. So we rewrite the documents based on this. And there's a system it uses to read it. And then there's another system that displays it. And these all have to be in sync at all times. And these weren't in sync. So I kept updating one and the other one was working right there. So I said, "All right, let's look at the overall app and let's look at the codebase and see what's out of sync here." And if I hadn't done that, it would just kept going in that endless loop where I was fixing one thing, but it was breaking another thing. And so you have to sit down and ask it to look at the codebase and you have to sit through and think about what's happening in your codebase and where it's going wrong at and where things are out of sync and where the poss solution could be popping up at because claude doesn't know if you say just fix this one thing uh it's going to go fix that one thing but it doesn't know this other thing is relevant to the other thing unless you make it clear and so then what I did after that is I made and updated the claw MD to say these things must always be in sync no codes after that you have to think about where the bug occurred why it's happening and then create rules so it doesn't happen again especially context or not rules context so claud is aware of it for example with the extension as well there was a there was a um a catching issue with Chrome and Chrome kept not updating the catch and so we'd upload something and it would show the wrong thing and it would shoot back claw the wrong code but claude didn't know Chrome was was not catching so we needed to go and test it and so I said what could the issue possibly be it gave me three different issues one of them was a catching issue I went through and tested it myself said okay we got this catching issue, we need to develop something in the software that gets around that catching issue when we upload later on and then when we see stuff coming in or a bug, always check for the catching issue first. We never have the catching issue anymore. This is how bug fixing works in Cloud. The other thing you need to do when you're thinking about running in the bugs is you're going to run the bugs and just sending it you can you can send cloud a screenshot. You can send it an error report. You can describe what went wrong. These are all great, but what's better when you see something going wrong in your software, particularly as an output, you need to have Claude go and for example, I'll show you with my system. So, if you look at my extension right here and you see this pop out and we go and bring this down, you can see I have this log system right here. Okay? And so, the point of this is we when I would run in the errors with the extension and I'd see bad outputs coming back, I don't want just to explain to Claude, I want a deep detailed log. And one of the things Claude is exceptional at is you say, "All right, where are all the things that can go wrong with this app or this this error is popping up right here? How can we create something that's going to give you a very detailed code technical explanation of why it's happening?" And it will think up test it can create for itself and then put these tests in there. So when you see things pop up, you can have documents that you can feed back to it and say, "All right, here's what went wrong. Read this. Why did it go wrong? Look at the codebase. Think about why it's going. Give me poss give me why it's happening. give us possible solutions and in ways to prevent it from happening in the future. Bam. You're not dealing with [&nbsp;__&nbsp;] guesswork when you're dealing with with this this [&nbsp;__&nbsp;] anymore. Finally, when you do a code review, it can be as simple as saying, "Claude, do a code review." One thing that is very helpful is you can have Codeex and Claude and another Claude agent has no codecs all review the code and then send all the reports back to the main code Claude agent and then say, "Hey," and this is something I stole from the Lenny podcast YouTube as well. and you can say, "Hey, here's what's wrong in the software. Either explain why this is incorrect or fix it." That's another way to fix it. But then finally, when you have it do the code review, all those MD files and everything you just put into the software is what the code review is going to use to review everything. And the context of it is whether it's wrong or not. If you give a person a huge codebase and you say, "Tell me where the bugs are." Something could fit together architecturally just fine, but it's not the intended output of the software or it misses the point of the software. If it doesn't have this, it's going to put stuff in there that doesn't make any sense. So, you need to have all this context. The final thing I'm going to tell you is whenever you're done coding or whenever you're done working with Claude, what you're going to want to do is you need to have this little [&nbsp;__&nbsp;] update everything. And the more complicated your system is, the more technical docs, you can see this doc area right here that I have in VS Code right here, the more advanced your Claude and your architecture and your your documents going to be. So keep these really clean and but you're but every time I build something new the architecture updates. Every time I add something new about how the feature works the PRD updates. Every time we learn something or we need rules or ways that it works with or things for etc. the cloud MD updates. Okay. On top of this when you're building really advanced stuff inside each folder or inside each thing you're building you can still have other rule systems in there that claude looks at before it gets into the folder. So if it's going into this part of the app right here and this is just a onepage app. So it doesn't have lots of folders or whatnot. But let's say we're just getting into something in the API. All right, I could have a note or a Claude MD in the API that says, "Hey, wait before you do this, make sure it aligns with this other part of the software and these are always in sync." Now, the reason why you do this is because you don't want Claude always opening up files, okay, and reading it because it takes up your your context window. That said, you want it when it digs into something relevant to know where to look and specific things to check that are very very important. Okay, so these are just other little general tips that really are going to save your life when you're doing this. Finally, my last tip for you when you're building these things is make sure Claude explicitly builds in ways that parts of the software are segmented from each other because remember that context window. Let's imagine you have chapter one of your book, chapter 2, and chapter 3. Let's imagine you keep these all super duper cleanly and there's little context at the beginning of chapter one and the end of chapter one on the rest of the book. So it's a summary of the book on each side, but the the AI can cleanly work on one chapter at a time and they don't mess with each other too much. If you have a code system, it's all a bunch of interlin things. Think about a plumbing system. Okay, much better analogy. It's a bunch of plumbing all intersected. If something over here changes and it messes up with that, well, Claude has to keep the entire plumbing system all in its mind. If you have a skyscraper where each floor has its own plumbing system and it doesn't need to understand how the plumbing system up here works, then what you're going to be able to do, and I know you're checking out the buys, it's good. Don't worry about it. What you're going to need to do is a lot less work because you can just put Claude on one floor and say, "Here's the context of the overall project, but you only need to understand what's on this floor right here." And it can work much better because it doesn't have to remember everything and blow its context window very fast. So, these are a bunch of things I do when I'm building in my company and how I think about the code and how I look at it. I think a lot of these things right here, you should your developer should know all these things. Okay? If your team isn't [&nbsp;__&nbsp;] doing this, your team's [&nbsp;__&nbsp;] and they suck. Sorry, but it's true. And your team should know these things. And if they don't know these things, they should be thinking these ways. You should have deep MD files for your software. You should have deep MD files for your UI. You should have parts of your software sign. All the things I talked about should be there times 10 on your real like deep product. Okay, that being said, as a non-technical founder, this allows you to do so much work on other parts of the software that are not directly connected to your deep back end of the complicated parts. It allows you to make stuff for your customers right away that gets them results very, very quickly. And those are the three ways to look at and these are the ways to build them from scratch. If you have a SAS company, you should be using highrisisk because it's going to make you a lot more money from your ads. So, that's that that's the real point of why I'm making this video. I want you to use my my my ad products. It'll make you a lot more money. But not before I give you good content, which is this video. So, this is the video. I've talked enough. This is everything I do when it comes to vibe coding or agentic coding. Have a nice day. If you guys like these videos, let me know. I can go into the actual how to use Claude MD and and more deeper stuff, but I think this is the only vibe code I'm gonna make because this is everything I think you need to know. Okay. Bye.